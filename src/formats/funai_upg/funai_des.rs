
const SBOX: [u32; 160] = [
    0x07, 0x0d, 0x0e, 0x03, 0x00, 0x06, 0x09, 0x0a, 0x01, 0x02, 0x08, 0x05, 0x0b, 0x0c, 0x04, 0x0f,
	0x0d, 0x08, 0x0b, 0x05, 0x06, 0x0f, 0x00, 0x03, 0x04, 0x07, 0x02, 0x0c, 0x01, 0x0a, 0x0e, 0x09,
	0x0a, 0x06, 0x09, 0x00, 0x0c, 0x0b, 0x07, 0x0d, 0x0f, 0x01, 0x03, 0x0e, 0x05, 0x02, 0x08, 0x04,
	0x03, 0x0f, 0x00, 0x06, 0x0a, 0x01, 0x0d, 0x08, 0x09, 0x04, 0x05, 0x0b, 0x0c, 0x07, 0x02, 0x0e,
	0x02, 0x0c, 0x04, 0x01, 0x07, 0x0a, 0x0b, 0x06, 0x08, 0x05, 0x03, 0x0f, 0x0d, 0x00, 0x0e, 0x09,
	0x0e, 0x0b, 0x02, 0x0c, 0x04, 0x07, 0x0d, 0x01, 0x05, 0x00, 0x0f, 0x0a, 0x03, 0x09, 0x08, 0x06,
	0x04, 0x02, 0x01, 0x0b, 0x0a, 0x0d, 0x07, 0x08, 0x0f, 0x09, 0x0c, 0x05, 0x06, 0x03, 0x00, 0x0e,
    0x0b, 0x08, 0x0c, 0x07, 0x01, 0x0e, 0x02, 0x0d, 0x06, 0x0f, 0x00, 0x09, 0x0a, 0x04, 0x05, 0x03,

	0x10, 0x07, 0x14, 0x15, 0x1d, 0x0c, 0x1c, 0x11, 0x01, 0x0f, 0x17, 0x1a, 0x05, 0x12, 0x1f, 0x0a,
	0x02, 0x08, 0x18, 0x0e, 0x00, 0x1b, 0x03, 0x09, 0x13, 0x0d, 0x1e, 0x06, 0x16, 0x0b, 0x04, 0x19,
];

#[inline(always)]
fn des_function(mut state: u32, key: u32) -> u32 {
    state ^= key;

    let mut block_state = 0u32;

    for i in 0..8 {
        let offset = (state & 0xF) as usize + i * 16;
        state >>= 4;
        block_state = (SBOX[offset] << 28) | (block_state >> 4);
    }

    let mut out = 0u32;
    for i in 0..32 {
        out = (out | ((block_state >> SBOX[128 + i]) & 1)) << 1;
    }

    out
}

pub fn funai_des_decrypt(input: &[u8], key: u32) -> Vec<u8> {
    assert!(input.len() % 8 == 0);
    let mut buf = input.to_vec();

    for chunk in buf.chunks_exact_mut(8) {
        let in1 = u32::from_le_bytes(chunk[0..4].try_into().unwrap());
        let in2 = u32::from_le_bytes(chunk[4..8].try_into().unwrap());

        let out2 = des_function(in2, key) ^ in1;
        let out1 = in2;

        chunk[0..4].copy_from_slice(&out1.to_le_bytes());
        chunk[4..8].copy_from_slice(&out2.to_le_bytes());
    }

    buf
}