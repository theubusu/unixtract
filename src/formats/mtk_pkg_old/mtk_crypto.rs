//dword_78A9B0
const P_TABLE_1: [u8; 24] = [
    0x00, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0C, 0x0B,
    0x0A, 0x09, 0x08, 0x07, 0x08, 0x07, 0x06, 0x05,
    0x04, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00, 0x0F,
];

//dword_78AA10
const S_BOX: [u8; 256] = [
    0x0D, 0x06, 0x00, 0x0A, 0x0E, 0x03, 0x0B, 0x05, 0x07, 0x01, 0x09, 0x04, 0x02, 0x08, 0x0C, 0x0F,
    0x00, 0x05, 0x0A, 0x03, 0x07, 0x09, 0x0C, 0x0F, 0x0B, 0x02, 0x06, 0x0D, 0x08, 0x0E, 0x01, 0x04,
    0x08, 0x03, 0x05, 0x09, 0x0B, 0x0C, 0x06, 0x0A, 0x01, 0x0D, 0x02, 0x0E, 0x04, 0x07, 0x0F, 0x00,
    0x07, 0x00, 0x09, 0x05, 0x0C, 0x06, 0x0A, 0x03, 0x08, 0x0B, 0x0F, 0x02, 0x01, 0x0D, 0x04, 0x0E,
    0x09, 0x0E, 0x05, 0x00, 0x0C, 0x07, 0x06, 0x0B, 0x02, 0x04, 0x0F, 0x03, 0x01, 0x0A, 0x08, 0x0D,
    0x0F, 0x02, 0x03, 0x09, 0x06, 0x0C, 0x08, 0x05, 0x01, 0x0D, 0x04, 0x0A, 0x0B, 0x07, 0x0E, 0x00,
    0x05, 0x0B, 0x09, 0x06, 0x0A, 0x01, 0x00, 0x0C, 0x0E, 0x08, 0x02, 0x0F, 0x07, 0x04, 0x0D, 0x03,
    0x0A, 0x05, 0x00, 0x0C, 0x0D, 0x02, 0x07, 0x09, 0x04, 0x03, 0x0B, 0x06, 0x0E, 0x08, 0x01, 0x0F,
    0x0C, 0x02, 0x05, 0x0B, 0x03, 0x0E, 0x0F, 0x04, 0x07, 0x08, 0x09, 0x06, 0x00, 0x0D, 0x0A, 0x01,
    0x07, 0x0E, 0x0A, 0x05, 0x0C, 0x02, 0x01, 0x0B, 0x00, 0x03, 0x0F, 0x08, 0x09, 0x04, 0x06, 0x0D,
    0x01, 0x0F, 0x0B, 0x0C, 0x0E, 0x05, 0x08, 0x02, 0x0A, 0x06, 0x04, 0x03, 0x09, 0x00, 0x07, 0x0D,
    0x08, 0x02, 0x04, 0x0B, 0x07, 0x0C, 0x0D, 0x01, 0x05, 0x0F, 0x03, 0x06, 0x0E, 0x09, 0x00, 0x0A,
    0x0E, 0x02, 0x07, 0x0C, 0x0B, 0x05, 0x04, 0x09, 0x08, 0x0D, 0x01, 0x0A, 0x06, 0x00, 0x0F, 0x03,
    0x04, 0x08, 0x02, 0x05, 0x0E, 0x03, 0x01, 0x0F, 0x0D, 0x07, 0x0B, 0x0C, 0x00, 0x09, 0x06, 0x0A,
    0x09, 0x0E, 0x0A, 0x01, 0x0C, 0x02, 0x07, 0x04, 0x03, 0x00, 0x0F, 0x06, 0x05, 0x0B, 0x08, 0x0D,
    0x0F, 0x04, 0x0C, 0x0B, 0x05, 0x08, 0x02, 0x01, 0x0A, 0x09, 0x06, 0x00, 0x03, 0x0E, 0x0D, 0x07,
];

//dword_78AE10
const P_TABLE_2: [u8; 16] = [
    0x0C, 0x08, 0x05, 0x00, 0x0A, 0x02, 0x0E, 0x07,
    0x04, 0x09, 0x01, 0x0D, 0x03, 0x06, 0x0B, 0x0F,
];


//sub_379C90
fn permute_24bit(input: u16, table: &[u8]) -> u32 {
    let mut output = 0u32;
    for (i, &bit_pos) in table.iter().enumerate().take(24) {
        if bit_pos < 32 && ((input >> bit_pos) & 1) != 0 {
            output |= 1 << i;
        }
    }
    output
}

//sub_379CB8
fn sbox_substitute(input: u32) -> u16 {
    let mut output = 0u16;
    for i in 0..4 {
        let bits6 = ((input >> (i * 6)) & 0x3F) as usize;
        let row_offset = 64 * i;
        let index = row_offset + bits6;
        let sbox_value = (S_BOX[index] & 0x0F) as u16;

        output |= sbox_value << (4 * i);
    }
    output
}

//sub_379CE6
fn permute_16bit(input: u16, table: &[u8]) -> u16 {
    let mut output = 0u16;
    for (i, &target_bit) in table.iter().enumerate().take(16) {
        if ((1 << i) & input) != 0 {
            output |= 1 << target_bit;
        }
    }
    output
}

//sub_379D0E
fn round_function(input16: u16, key16: u16) -> u16 {
    let perm_input = permute_24bit(input16, &P_TABLE_1);
    let perm_key = permute_24bit(key16, &P_TABLE_1);
    let xor_result = perm_input ^ perm_key;
    
    let sbox_output = sbox_substitute(xor_result);
    
    permute_16bit(sbox_output, &P_TABLE_2)
}

//sub_379DE8
fn decrypt_block(encrypted32: u32, key_upper: u16, key_lower: u16, prev_block: u32) -> u32 {
    let lower_half = (encrypted32 & 0xFFFF) as u16;
    let upper_half = ((encrypted32 >> 16) & 0xFFFF) as u16;
    
    //round 1
    let mut temp1 = round_function(lower_half, key_upper);
    temp1 ^= upper_half;
    
    //round 2
    let mut temp2 = round_function(temp1, key_lower);
    temp2 ^= lower_half;
    
    let decrypted = ((temp2 as u32) << 16) | (temp1 as u32);

    decrypted ^ prev_block
}

pub fn decrypt(data: &[u8], key: u32, xor_mask: Option<u32>) -> Vec<u8> {
    let key_upper = ((key >> 16) & 0xFFFF) as u16;
    let key_lower = (key & 0xFFFF) as u16;
    
    let mut decrypted = Vec::with_capacity(data.len());
    let mut prev_block = 0u32; //initial iv = 0
    
    //calculate how many complete 4 byte blocks
    let aligned_len = (data.len() / 4) * 4;
    
    for chunk in data[..aligned_len].chunks_exact(4) {
        let encrypted32 = u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);
        let decrypted32 = decrypt_block(encrypted32, key_upper, key_lower, prev_block);
        
        decrypted.extend_from_slice(&decrypted32.to_le_bytes());
        prev_block = encrypted32;
    }
    
    //the remaining bytes that are not 4 byte blocks are just XORed with 0x3D
    for &byte in &data[aligned_len..] {
        decrypted.push(byte ^ 0x3D);
    }
    
    //apply XOR to the first 4 bytes if a mask is provided
    if let Some(mask) = xor_mask {
        if decrypted.len() >= 4 {
            let first_dword = u32::from_le_bytes([
                decrypted[0],
                decrypted[1],
                decrypted[2],
                decrypted[3],
            ]);
            let xored = first_dword ^ mask;
            decrypted[0..4].copy_from_slice(&xored.to_le_bytes());
        }
    }
    
    decrypted
}