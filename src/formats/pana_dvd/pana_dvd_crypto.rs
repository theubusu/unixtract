//libfmupre.so
//DAT_29f06d60
const SBOX: [u8; 256] = [
    0x00,0x01,0xbb,0x9c,0x3f,0x5e,0xc7,0x3e,0x36,0xa4,0x92,0x93,0x38,0x9b,0x8d,0x1a,
    0x3c,0x84,0xf7,0x2a,0xcb,0x3d,0x70,0xad,0x30,0xa2,0xc1,0x95,0x03,0x39,0xa5,0x0e,
    0xe6,0xfb,0x09,0x1e,0xb9,0xc4,0x24,0x57,0x5f,0xc3,0x5d,0xfa,0x60,0x56,0xfd,0xed,
    0x81,0xf3,0x4a,0xff,0x85,0xdb,0xcd,0xa0,0xd0,0x9d,0x8b,0x26,0x4c,0x50,0x0c,0x1d,
    0x7d,0x77,0xde,0x7a,0x0a,0x0b,0x73,0xe1,0x54,0x76,0xe8,0xc2,0x28,0x05,0x98,0x99,
    0x29,0x4b,0xee,0x87,0x42,0x59,0x65,0xb8,0x1f,0xdf,0x23,0x58,0x63,0x69,0x1c,0x79,
    0x64,0xc5,0x6f,0x13,0x3b,0xce,0x08,0xa7,0xb2,0x12,0x20,0x7f,0xe2,0x89,0x21,0x2b,
    0x41,0x49,0x7c,0x82,0xbe,0xf2,0x43,0x8e,0x86,0x02,0x9e,0xd8,0x67,0x8f,0xa3,0xe7,
    0xbc,0xf8,0x66,0x22,0x4d,0xe5,0xba,0xd2,0xda,0xea,0x61,0x25,0xb0,0xc0,0x7b,0xa6,
    0x48,0x96,0xdd,0xdc,0x71,0x90,0x55,0x5b,0x4f,0x4e,0x6d,0xd1,0x11,0x34,0xaa,0x1b,
    0xf4,0x17,0x80,0xb7,0xcc,0x8c,0xd9,0x37,0x8a,0x2c,0x94,0x16,0x72,0x40,0xef,0x9a,
    0xc8,0x47,0xf6,0xfc,0x2e,0xb3,0x2f,0xbd,0xcf,0xa9,0x15,0x10,0x18,0xec,0x6a,0x6e,
    0xc9,0x91,0x53,0x78,0xa8,0x3a,0xaf,0x0d,0xe0,0x97,0x32,0x51,0xb1,0xf5,0x27,0x2d,
    0x35,0x88,0x14,0xe3,0xfe,0x06,0xd7,0xd6,0xab,0xa1,0xd5,0xe4,0x45,0x44,0x9f,0x0f,
    0x5a,0x83,0xeb,0xca,0x07,0x04,0xb4,0xb6,0x52,0xae,0xd4,0x33,0x31,0x75,0xd3,0x6c,
    0x62,0xbf,0x6b,0xf9,0xac,0x46,0xf0,0x5c,0x19,0x7e,0x68,0xb5,0xf1,0x74,0xc6,0xe9,
];

//FUN_29f05520
fn round_function(state: &mut [u8; 4], a5: &[u8; 4]) {
    let v5 = a5[1] ^ state[1];
    let v6 = a5[2] ^ state[2];
    let v7 = state[3] ^ a5[3];

    let v8 = ((v5 >> 7) | (v5 << 1)) & 0xFF;
    let v9 = ((v6 >> 5) | (v6 << 3)) & 0xFF;
    let v10 = a5[0] ^ state[0];
    let v11 = ((v7 >> 2) | (v7 << 6)) & 0xFF;
    let v12 = v10 ^ v9 ^ v8;

    let temp_v7 = v10 >> 1;
    let temp_v10 = ((v10 << 7) | (v11 >> 1)) & 0xFF;

    let new_a4 = ((v9 >> 1) | (v11 << 7)) & 0xFF;
    let v13 = SBOX[(v11 ^ v12) as usize];
    let new_a3 = ((v8 >> 1) | (v9 << 7)) & 0xFF;
    let new_a2 = (temp_v7 | (v8 << 7)) & 0xFF;
    let new_result = temp_v10 & 0xFF;

    let a4_final = new_a4.wrapping_add(v13);
    let a3_final = new_a3.wrapping_add(((v13 >> 7) | (v13 << 1)) & 0xFF);
    let a2_final = new_a2.wrapping_add(((v13 >> 6) | (v13 << 2)) & 0xFF);
    let result_final = new_result.wrapping_add(((v13 >> 5) | (v13 << 3)) & 0xFF);

    state[0] = result_final;
    state[1] = a2_final;
    state[2] = a3_final;
    state[3] = a4_final;
}

//FUN_29f055dc
fn key_schedule(xored_key: &[u8; 8], out: &mut [u8; 32]) {
    //in original function 2 keys were XORed together to make the actual key (that the round keys are derived from)
    // why? i dont know (obfuscation?) but i use the XORed key here directly
    let mut v26 = [0u8; 8];
    for i in 0..7 {
        v26[i] = xored_key[i];
    }
    let v12 = xored_key[7];
    v26[1] ^= v12;
    v26[4] ^= v12;

    for i in 0..7 {
        out[i] = v26[i];
    }
    for i in 7..32 {
        out[i] = 0;
    }

    let mut v22: [u8; 4] = [53, 125, 251, 154];

    for v16 in 0..16 {
        let v17 = 4 * (v16 & 7);
        let mut state: [u8; 4] = out[v17..v17 + 4].try_into().unwrap();
        round_function(&mut state, &v22);
        out[v17..v17 + 4].copy_from_slice(&state);
        v22.copy_from_slice(&state);
    }
}

//FUN_29f056b0
fn decrypt_block(a1: &[u8; 32], a2: &mut [u8; 8]) {
    let mut v6 = a2[0];
    let mut v7 = a2[1];
    let mut v5 = a2[2];
    let mut v4 = a2[3];

    let mut v24 = v6;
    let mut v25 = v7;
    let mut v26 = v5;
    let mut v27 = v4;

    let mut v10 = a2[4];
    let mut v11 = a2[5];
    let mut v12 = a2[6];
    let mut v13 = a2[7];

    let mut v15: u8 = 0;
    let mut v16: u8 = 0;
    let mut v17: u8 = 0;
    let mut v18: u8 = 0;

    for v2 in (0..16).rev() {
        let v14 = (v2 & 7) as usize;
        let subkey: [u8; 4] = a1[4 * v14..4 * v14 + 4].try_into().unwrap();
        let mut st = [v24, v25, v26, v27];
        round_function(&mut st, &subkey);
        v24 = st[0];
        v25 = st[1];
        v26 = st[2];
        v27 = st[3];

        v15 = v10 ^ v24;
        v16 = v11 ^ v25;
        v17 = v12 ^ v26;
        v18 = v13 ^ v27;

        v24 ^= v10;
        v25 ^= v11;
        v26 ^= v12;
        v27 ^= v13;

        v10 = v6;
        v11 = v7;
        v12 = v5;
        v13 = v4;

        if v2 == 0 {
            break;
        }

        v6 = v15;
        v7 = v16;
        v5 = v17;
        v4 = v18;
    }

    a2[0] = v6;
    a2[1] = v7;
    a2[2] = v5;
    a2[3] = v4;
    a2[4] = v15;
    a2[5] = v16;
    a2[6] = v17;
    a2[7] = v18;
}

fn decrypt_data_inplace(data: &mut [u8], key: &[u8; 8]) {
    let mut subkeys = [0u8; 32];
    key_schedule(key, &mut subkeys);
    for chunk in data.chunks_mut(8) {
        if chunk.len() == 8 {
            let mut block: [u8; 8] = chunk.try_into().unwrap();
            decrypt_block(&subkeys, &mut block);
            chunk.copy_from_slice(&block);
        }
    }
}

pub fn decrypt_data(data: &[u8], key: &[u8; 8]) -> Vec<u8> {
    let mut buf = data.to_vec();
    decrypt_data_inplace(&mut buf, key);
    buf
}